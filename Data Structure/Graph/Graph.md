## گراف
گراف را به صورت `(V,E)=G` نشان می دهیم که `V` راس و `E` یال های گراف است. مجموع درجه های گراف نیز دو برابر تعداد یال ها است یعنی `S=2V`.

### گراف کامل
گراف بدون جهتی که همه یالهای آن رسم شده است. درجه هر گره `n-1` و تعاد یال ها `2/(n(n-1` است.

### گراف همبند
گرافی که یک مسیر بین دو گره آن وجود داشته باشد.

### گراف همبند قوی
گراف جهت داری که برای هر زوج گره `v,u` هم یک مسیر `uv` و هم یک مسیر `vu` وجود دارد.

### گراف دو قسمتی (Bipartite)
گرافی که نود های آن قابل دسته بندی به دو مجموعه مستقل `U, V` هستند. هر یال در این گراف نودی از مجموعه `U` را به نودی در مجموعه `V` وصل می کند. این گراف را معمولا به صورت `(V,U,E)=G` نمایش می دهند.

### زیر گراف (Subgraph)
یک زیر گراف از گراف `(V,E)=G`، یک گراف `(W,F)=H` است.

## نمایش گراف
1. ماتریس همجواری (Adjacency Matrices)
2. لیست همجواری (Adjacency List)

### ماتریس همجواری
- مجموع عدد `1` در ماتریس همان مجموع درجات هست.
- تعداد عدد `1` در هر سطر یا هر ستون همان درجه آن گره است.

### لیست همجواری
- تعداد نود ها همان درجات گراف است.
- درجه یک گره همان تعداد نود های موجود در لیست آن گره است.

### کدام روش بهتر است؟
روش لیست همجواری بهتر است آنگونه که در رفرنس ها گفته شده. اما اگر شرایط زیر را داشته باشبم:
- اگر گراف ما گراف اسپارس `|E| << |V|*|V|` باشد: روش لیست همجواری
- اگر گراف ما گراف چگال باشد: روش ماتریس همجواری

#### از نظر حافظه اگر نگاه کنیم می بینیم که:
- در ماتریس همجواری تتا از مرتبه `n^2` است.
- در لیست همجواری تتا از مرتبه `V + E` است.

## پیمایش گراف
- پیمایش سطحی (Breadth First Search)
- پیمایش عمقی (Depth First Search)

### پیمایش سطحی (DFS)
با شروع از یک گره ابتدا گره را وارد صف کرده سپس کلیه گره های مجاور آن (فرزندان گره از چپ به راست) را در صف درج می کنیم. حال عنصر بعدی را از صف حذف کرده و گره های مجاور آن را درج می کنیم. این عمل را ادامه می دهیم تا همه گره ها پیمایش شوند.
- در پیمایش سطحی از `Queue` استفاده می کنیم.

### تابع پیمایش سطحی
شبه کد پیمایش سطحی (DFS) به صورت زیر است:
```pseudocode
BFS(G, s)
  for each vertex (u from G.V - {s})
    u.color = WHITE
    u.d = infinitive
    u.pi = NULL
  s.color = GRAY
  s.d = 0
  s.pi = NULL
  Q = {}
  ENQUEUE(Q, s)
  while Q != {}
    u = DEQUEUE(Q)
    for each (v from G.Adj[u])
      if v.color == WHITE
        v.color = GRAY
        v.d = u.d + 1
        v.pi = u
        ENQUEUE(Q.V)
    u.color = BLACK
```
اگر روی یک گراف پیمایش سطحی (DFS) بزنیم گراف به دست آمده درخت خواهد بود.

